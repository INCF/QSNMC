"""Tests corresponding to the 2009 QSNMC competition, Challenge A."""

from __future__ import division

import sys

import numpy as np
import sciunit
import sciunit.scores
from neuronunit.capabilities import ProducesSpikes
from NeuroTools.signals import AnalogSignal
from NeuroTools.signals.spikes import SpikeTrain

from ..capabilities import TrainVoltageOnCurrent,load_training_data
from ..comparators import SpikeTrainComparator

###################
# Available Tests #
###################

# Could be moved to neuronunit.tests.  

class SpikeTrainComparisonTest(sciunit.Test):
    """Compares spike trains for concordance of spike times."""

    def __init__(self,
                 observation={'current':None,'spike_trains':[]},
                 name="Spike train comparison test",
                 delta=1, 
                 T=None, 
                 method='Rect'):
        """
        observation['current']: a NeuroTools AnalogSignal corresponding to
                                    the injected current.    
        observation['spike_trains']: a list of spike trains, where each spike 
                                     train is a NeuroTools SpikeTrain.  
        delta: The window width for computing similarity (ms). 
        T: Spike count array will be generated by observed spike 
                     trains from 0 to T seconds.  Defaults to duration of
                     first spike train.  
        method: 'Rect' or 'Kistler', corresponding to two methods for 
                          computing MDstar.  
        """

        dt = observation['current'].dt
        if T is None: # If no duration given.      
            first_train = observation['spike_trains'][0]
            # Assume all trains have equal duration.  
            T = first_train.duration()
        
        params = {'delta': delta, 'dt': dt, 'T':T, 'method': method}
        sciunit.Test.__init__(self,observation,name,**params)
        self.required_capabilities += (ProducesSpikes,)

    description = "A test of the similarity of spike trains."

    score_type = sciunit.scores.PercentScore

    def validate_observation(self, observation):
        try:
            assert type(observation) is dict, 'Observation must be a dict'
            assert type(observation['spike_trains']) is list, \
                "observation['spike_trains'] must be a list"
            for spike_train in observation['spike_trains']:
                assert type(spike_train) is SpikeTrain, \
                    "Each spike_train must be a NeuroTools SpikeTrain"
            assert type(observation['current']) is AnalogSignal, \
                "observation['spike_trains'] must be a NeuroTools AnalogSignal"
        except AssertionError,e:
            raise sciunit.ObservationError(e.message)

    def generate_prediction(self, model):
        """Implementation of sciunit.Test.generate_prediction."""
        model.inject_current(self.observation['current']) 
        model_spike_trains = model.get_spike_trains()
        prediction = {'spike_trains':model_spike_trains}
        return prediction

    def compute_score(self, observation, prediction):
        """Implementation of sciunit.Test.score_prediction."""
        observed = observation['spike_trains']
        predicted = prediction['spike_trains']
        T = self.params['T']
        comparator = SpikeTrainComparator(T,observed,predicted)
        comparator.compute = getattr(comparator,"computeMD_%s" % self.params['method'])
        delta = self.params['delta']
        dt = self.params['dt']
        MDstar = comparator.compute(delta, dt) 
        score = self.score_type(MDstar * 100.0)
        score.related_data.update(self.params)
        return score

#######################
# Auxiliary Functions #
#######################

def load_testing_data():
    pass # Not implemented until security is worked out.  

####################
# Tests to execute #
####################

dt = 1e-4 # 10 kHz sampling. 

# Training data.
current_array,voltage_array = load_training_data() 
spike_trains = []
for col in range(voltage_array.shape[1]):
    voltage_trial = voltage_array[:,col]
    vm_trial = AnalogSignal(voltage_trial,dt)  
    spike_train = vm_trial.threshold_detection(0)
    spike_trains.append(spike_train)
current = AnalogSignal(current_array,dt)

observation = {'current':current,'spike_trains':spike_trains}

training = SpikeTrainComparisonTest(observation=observation,
                                    name="Test on Training Data")

# Test data. Using training data until security is worked out.    
current,voltage = load_training_data() 
test = SpikeTrainComparisonTest(observation=observation,
                                name="Test on Test Data")

# Two tests, one indicating agreement with training data, and one indicating
# agreement with test data.  A leaderboard can be constructed from the training 
# data, but the real leaderboard will use the test data.  
tests = [training,test]

